<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Meu Processo — Andamento</title>

  <!-- estilos simples (opcional) -->
  <link rel="stylesheet" href="/styles.css"/>

  <!-- nosso app.js com as funções Supabase -->
  <script defer src="/app.js"></script>
</head>
<body>
  <h1>Meu Processo</h1>

  <!-- Cabeçalho / dados do caso -->
  <div id="content" class="card">Carregando...</div>

  <!-- Avisos do Escritório -->
  <div class="card">
    <h3>
      Avisos do Escritório
      <span id="badge" class="badge" style="display:none">Novo</span>
    </h3>
    <ul id="notices"></ul>
    <small>Toque em um aviso para marcar como lido.</small>
  </div>

  <!-- Upload de documento pelo cliente -->
  <div class="card">
    <h3>Enviar documento</h3>
    <input type="file" id="file"/>
    <button id="send">Enviar</button>
    <small>Formatos comuns aceitos (PDF, JPG, PNG etc.).</small>
  </div>

  <script>
    // token do caso (vem no link /case.html?token=...)
    const params = new URLSearchParams(location.search);
    const token = params.get('token');
    if (!token) {
      document.getElementById('content').innerText = 'Link inválido (faltou o token).';
      throw new Error('Token ausente');
    }

    // carrega dados do caso + eventos + arquivos + notificações
    async function load() {
      // dados do caso
      const { data: c, error: e1 } = await getCaseByToken(token);
      if (e1 || !c) {
        document.getElementById('content').innerText = 'Processo não encontrado.';
        return;
      }

      // eventos (andamentos)
      const { data: ev } = await getEventsByToken(token);

      // arquivos
      const { data: files } = await getFilesByToken(token);

      // notificações
      const { data: notes } = await getNotificationsByToken(token);

      // monta header + timeline
      const html = [
        `<h2>${c.title}</h2>`,
        `<div><small><b>Código:</b> ${c.code}</small></div>`,
        '<h3>Andamento</h3>',
        '<ul>'
      ];
      (ev || []).forEach(x => {
        html.push(
          `<li>
            <span class="dot"></span>
            <b>${x.status}</b> — ${x.description || ''}
            <br/><small>${new Date(x.created_at).toLocaleString('pt-BR')}</small>
          </li>`
        );
      });
      html.push('</ul>', '<h3>Documentos</h3>', '<ul>');

      // assina URL de cada arquivo para download seguro
      if (files && files.length) {
        for (const f of files) {
          const { data: signed } = await signStorageUrl(f.s3_key, 60);
          const kb = Math.max(1, Math.round((f.size_bytes || 0) / 1024));
          html.push(
            `<li>
              <a href="${signed?.signedUrl || '#'}" ${signed?.signedUrl ? 'download' : ''}>
                ${f.file_name}
              </a>
              <small> (${kb} KB) • ${f.uploaded_by === 'CLIENT' ? 'Você' : 'Escritório'}</small>
            </li>`
          );
        }
      } else {
        html.push('<li><small>Nenhum documento disponível ainda.</small></li>');
      }
      html.push('</ul>');

      document.getElementById('content').innerHTML = html.join('');

      // renderiza notificações
      renderNotices(notes || []);
    }

    function renderNotices(notes) {
      const ul = document.getElementById('notices');
      ul.innerHTML = '';
      let unread = 0;

      notes.forEach(n => {
        const dt = new Date(n.created_at).toLocaleString('pt-BR');
        const isUnread = !n.read_at;
        if (isUnread) unread++;

        const li = document.createElement('li');
        li.style.cursor = 'pointer';
        li.innerHTML = `<b>${n.message}</b> <br/><small>${dt}${isUnread ? ' • não lido' : ''}</small>`;
        li.onclick = async () => {
          if (!n.read_at) {
            await markNotificationRead(n.id);
            // atualiza UI sem recarregar tudo
            n.read_at = new Date().toISOString();
            li.querySelector('small').innerHTML = dt; // remove marcador "não lido"
            refreshBadge(notes);
          }
        };
        ul.appendChild(li);
      });

      // badge "Novo"
      function showBadge(show) {
        document.getElementById('badge').style.display = show ? 'inline-block' : 'none';
      }
      showBadge(unread > 0);
    }

    function refreshBadge(notes) {
      const unread = (notes || []).filter(n => !n.read_at).length;
      document.getElementById('badge').style.display = unread > 0 ? 'inline-block' : 'none';
    }

    // upload de arquivo pelo cliente
    document.getElementById('send').onclick = async () => {
      try {
        const file = document.getElementById('file').files[0];
        if (!file) return alert('Selecione um arquivo.');

        // precisamos do ID do caso para montar o caminho do arquivo
        const { data: c } = await getCaseByToken(token);
        const path = `${c.id}/${Date.now()}-${file.name}`;

        const up = await uploadFile(path, file);
        if (up.error) throw up.error;

        // registra na tabela case_files (marcando que veio do CLIENT)
        const meta = {
          case_id: c.id,
          file_name: file.name,
          content_type: file.type || 'application/octet-stream',
          size_bytes: file.size || 0,
          s3_key: up.data.path,
          uploaded_by: 'CLIENT'
        };
        const ins = await operatorAttachFile(meta);
        if (ins.error) throw ins.error;

        alert('Documento enviado com sucesso!');
        location.reload();
      } catch (err) {
        alert('Falha no envio: ' + (err.message || JSON.stringify(err)));
        console.error(err);
      }
    };

    // inicia
    load();
  </script>
</body>
</html>
